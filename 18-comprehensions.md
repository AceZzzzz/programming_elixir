18-领悟
========
[生成器和过滤器]()<br/>
[Bitstring生成器]()<br/>
[Into]()<br/>

>Comprehensions翻译成“领悟”不知道贴不贴切。原作者是想引用些魔法玄幻小说的词汇吧。

Elixir中，使用枚举类型做循环操作是很常见的，并且通常要过滤一些结果，并且映射一些别的列表的值。
领悟（comprehensions）就是为此目的诞生的语法糖：把这些常见任务分分组，放到特殊形式的```for```中执行。

例如，我们可以这样计算列表中每个元素的平方：
```
iex> for n <- [1, 2, 3, 4], do: n * n
[1, 4, 9, 16]
```

一个领悟由三部分组成：生成器，过滤器和集合。

##18.2-生成器和过滤器
在上面的例子中，```n <- [1,2,3,4]```就是生成器。它字面意思上生成了即将要在领悟中使用的数值。
任何枚举类型都可以传递给生成器表达式的右端：
```
iex> for n <- 1..4, do: n * n
[1, 4, 9, 16]
```

生成器表达式支持模式匹配，它会忽略所有不匹配的模式。
想象一下如果不用范围而是用一个键值列表，键只有```:good```和```:bad```两种，来计算元素平方：
```
iex> values = [good: 1, good: 2, bad: 3, good: 4]
iex> for {:good, n} <- values, do: n * n
[1, 4, 16]
```

过滤器能过滤掉某些产生的值。例如我们可以支队奇数进行平方运算：
```
iex> require Integer
iex> for n <- 1..4, Integer.odd?(n), do: n * n
[1, 9]
```
过滤器会保留所有非nil或false的值。

总的来说，领悟比直接使用枚举或流模块的函数提供了更精确的表述。
不但如此，领悟还接受多个生成器和过滤器。下面就是一个例子，代码接受目录列表，删除这些目录下的所有文件：
```
for dir  <- dirs,
    file <- File.ls!(dir),
    path = Path.join(dir, file),
    File.regular?(path) do
  File.rm!(path)
end
```






























