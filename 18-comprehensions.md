18-领悟
========
[生成器和过滤器]()<br/>
[Bitstring生成器]()<br/>
[Into]()<br/>

>Comprehensions翻译成“领悟”不知道贴不贴切。原作者是想引用些魔法玄幻小说的词汇吧。

Elixir中，使用枚举类型做循环操作是很常见的，并且通常要过滤一些结果，并且映射一些别的列表的值。
领悟（comprehensions）就是为此目的诞生的语法糖：把这些常见任务分分组，放到特殊形式的```for```中执行。

例如，我们可以这样计算列表中每个元素的平方：
```
iex> for n <- [1, 2, 3, 4], do: n * n
[1, 4, 9, 16]
```

一个领悟由三部分组成：生成器，过滤器和集合。

##18.2-生成器和过滤器
在上面的例子中，```n <- [1,2,3,4]```就是生成器。它字面意思上生成了即将要在领悟中使用的数值。
任何枚举类型都可以传递给生成器表达式的右端：
```
iex> for n <- 1..4, do: n * n
[1, 4, 9, 16]
```

生成器表达式支持模式匹配，它会忽略所有不匹配的模式。
想象一下如果不用范围而是用一个键值列表，键只有```:good```和```:bad```两种，来计算元素平方：
```
iex> values = [good: 1, good: 2, bad: 3, good: 4]
iex> for {:good, n} <- values, do: n * n
[1, 4, 16]
```

过滤器能过滤掉某些产生的值。例如我们可以支队奇数进行平方运算：
```
iex> require Integer
iex> for n <- 1..4, Integer.odd?(n), do: n * n
[1, 9]
```
过滤器会保留所有非nil或false的值。

总的来说，领悟比直接使用枚举或流模块的函数提供了更精确的表述。
不但如此，领悟还接受多个生成器和过滤器。下面就是一个例子，代码接受目录列表，删除这些目录下的所有文件：
```
for dir  <- dirs,
    file <- File.ls!(dir),
    path = Path.join(dir, file),
    File.regular?(path) do
  File.rm!(path)
end
```

需要记住的是，在领悟中，变量赋值这种事请在生成器中进行。因为在过滤器或代码块中的值不会反映到领悟外面去。

## 18.2-Bitstring生成器
领悟也支持Bitstring生成器。而且这种生成器在组织处理bitstring流是非常有用。
下面的例子中，程序从二进制数据（表示为像素1红，像素1绿，像素1蓝，像素2红，像素2绿。。。）中接收一个像素的列表，把它们转换为元组：
```
iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
```
bitstring生成器可以和“普通的”枚举生成器混合使用。过滤器也是。

## 18.3-Into
在上面的例子中，领悟返回一个列表作为结果。

但是，通过使用```:into```选项，领悟的结果可以插入到不同的数据结构中。
例如，你可以使用bitstring的生成器加上:into想想来轻松地移除字符串中的空格：
```
iex> for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>>
"helloworld"
```

集合、图以及其他字典类型都可以传递给:into选项。总的来说，:into选项接受任何实现了_Collectable_协议的数据结构。

例如，IO模块提供了流。流既是Enumerable也是Collectable。
你可以使用领悟实现一个回声终端，让其返回任何输入的东西的大写形式：
```
iex> stream = IO.stream(:stdio, :line)
iex> for line <- stream, into: stream do
...>   String.upcase(line) <> "\n"
...> end
```

现在在终端中输入任意字符串，你会看到同样的内容被以大写形式打印出来。
不幸的是，这个例子会让你的shell陷入那个领悟代码中去，你只能用Ctrl+C两次来退出。

